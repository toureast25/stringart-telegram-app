<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Telegram Mini App — Фото и Палитра</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
    :root {
      --bg: #0f1115;
      --card: #151924;
      --text: #e7e9ee;
      --muted: #9aa3b2;
      --accent: #2ea6ff;
      --border: #1f2430;
    }
    body { margin:0; font-family:system-ui,sans-serif; color:var(--text); background:var(--bg);}
    .app {display:flex;flex-direction:column;min-height:100dvh;}
    header.app-header{display:flex;gap:12px;padding:12px;background:var(--card);border-bottom:1px solid var(--border);}
    header.app-header button{border:1px solid var(--border);background:transparent;color:var(--text);padding:10px 14px;border-radius:12px;font-weight:600;cursor:pointer;}
    header.app-header button.primary{background:var(--accent);border-color:transparent;color:#081018;}
    main{display:grid;place-items:center;padding:16px;flex:1;}
    .card{width:min(720px,100%);background:var(--card);border:1px solid var(--border);border-radius:20px;box-shadow:0 10px 30px rgba(0,0,0,.35);overflow:hidden;}
    video{display:none;max-width:100%;border-top:1px solid var(--border);background:#000;}
    .preview{display:none;border-top:1px solid var(--border);background:#0c0f15;padding-bottom:10px;}
    .preview.active{display:block;}
    .preview-label{padding:10px 16px;font-weight:bold;}
    .preview img{display:block;width:100%;height:auto;object-fit:contain;background:#000;max-height:70dvh;}
    .second-preview{display:none;border-top:1px solid var(--border);padding:10px 16px;}
    .second-preview.active{display:block;}
    .second-preview img{width:100%;height:auto;}
    .settings{margin-top:10px;}
    .settings label{display:block;margin-top:8px;}
    .settings input[type=range]{width:60%;}
    .settings input[type=number]{width:80px;margin-left:10px;}
    .settings span{margin-left:10px;}
    .method-settings{margin-top:8px;padding:8px;background:rgba(255,255,255,0.05);border-radius:8px;border-left:3px solid var(--accent);}
    .palette {display:flex;flex-wrap:wrap;gap:10px;margin-top:10px;}
    .color-item{box-sizing:border-box;display:flex;flex-direction:column;align-items:center;justify-content:flex-start;margin:0;flex:0 0 calc((100% - 20px)/3);max-width:calc((100% - 20px)/3);}
    .color-circle{width:32px;height:32px;border-radius:50%;border:2px solid #fff;cursor:pointer;}
    .color-code{font-size:12px;margin-top:4px;width:72px;padding:2px 4px;}
    .color-controls{display:flex;align-items:center;gap:6px;margin-top:4px;}
    .pipette-btn{padding:4px 6px;line-height:1;border:1px solid var(--border);background:transparent;color:var(--text);border-radius:6px;cursor:pointer;}
    #colorMaps img{box-sizing:border-box;flex:0 0 calc((100% - 20px)/3);max-width:calc((100% - 20px)/3);border:2px solid var(--border);}
    .mapping-item{display:flex;align-items:center;gap:10px;margin-bottom:8px;padding:8px;background:rgba(255,255,255,0.03);border-radius:6px;}
    .mapping-colors{display:flex;align-items:center;gap:8px;}
    .mapping-arrow{color:var(--muted);font-size:18px;}
    .actual-color-item{position:relative;}
    .remove-color-btn{position:absolute;top:-8px;right:-8px;width:20px;height:20px;border-radius:50%;background:#ff4444;border:none;color:white;cursor:pointer;font-size:12px;line-height:1;}
    #actualMapsContainer img{box-sizing:border-box;flex:0 0 calc((100% - 20px)/3);max-width:calc((100% - 20px)/3);border:2px solid var(--border);}
    #stringartCanvas{display:block;margin:0 auto;}
  </style>
</head>
<body>
<div class="app">
  <header class="app-header">
    <button id="uploadBtn" class="primary" type="button">Выбрать файл</button>
    <button id="cameraBtn" type="button">Сделать фото</button>
    <button id="resetBtn" type="button" style="display:none">Сброс</button>
  </header>
  <main>
    <section class="card">
      <video id="cameraStream" autoplay playsinline></video>
      <canvas id="snapshotCanvas" style="display:none"></canvas>

      <!-- 1) -->
      <div id="preview" class="preview">
        <div class="preview-label">1)</div>
        <img id="previewImg" alt="Предпросмотр"/>
      </div>

      <!-- 2) -->
      <div id="secondPreview" class="second-preview">
        <div class="preview-label">2)</div>
        <img id="secondImg" alt="Изменённое"/>
        <div class="settings">
          <label>
            Ширина (px):
            <input type="range" id="resolutionRange" min="50" max="1000" step="1" value="200">
            <input type="number" id="resolutionInput" min="50" max="1000" step="1" value="200">
            <span id="percentDisplay">20%</span>
          </label>
          <label>
            Размытие (px):
            <input type="range" id="blurRange" min="0" max="20" step="0.1" value="0">
            <input type="number" id="blurInput" min="0" max="20" step="0.1" value="0">
          </label>
        </div>
      </div>

      <!-- 3) -->
      <div id="paletteSection" class="second-preview">
        <div class="preview-label">3)</div>
        <div id="backgroundSettings" class="settings">
          <label style="font-weight:bold;">Цвет фона:</label>
          <div class="color-controls">
            <button type="button" class="color-circle" style="background:#fff; border:2px solid #ccc;" data-bg="#ffffff" title="Белый"></button>
            <button type="button" class="color-circle" style="background:#000; border:2px solid #ccc;" data-bg="#000000" title="Чёрный"></button>
            <button type="button" class="color-circle" style="background:#888; border:2px solid #ccc;" data-bg="#888888" title="Серый"></button>
            <input type="color" id="bgColorPicker" value="#ffffff" title="Выбрать цвет" style="width:32px;height:32px;border:none;cursor:pointer;">
            <span id="currentBgColor" style="margin-left:10px;">#ffffff</span>
          </div>
          <div style="margin-top:10px;">
            <label>Ширина полосы для автоопределения (%):
              <input type="number" id="bgEdgePercent" min="1" max="50" value="10" style="width:60px;">
            </label>
          </div>
        </div>
        <div class="settings">
          <label>
            Метод кластеризации:
            <select id="clusteringMethod">
              <option value="kmeans">k-means</option>
              <option value="tones" selected>По тонам</option>
            </select>
          </label>
          <label>
            Кол-во цветов:
            <select id="colorCount">
              <option value="3" selected>3</option>
              <option value="6">6</option>
              <option value="9">9</option>
              <option value="12">12</option>
              <option value="15">15</option>
            </select>
          </label>
          <div id="kmeansSettings" class="method-settings">
            <!-- Настройки для k-means (пока пустые) -->
          </div>
          <div id="tonesSettings" class="method-settings" style="display:none;">
            <label>
              Минимальная ΔE:
              <input type="number" id="minDeltaE" min="1" max="100" value="25">
            </label>
            <label>
              Тёмные:
              <input type="number" id="darkCount" min="0" max="9" value="1" style="width:40px;">
            </label>
            <label>
              Средние:
              <input type="number" id="midCount" min="0" max="9" value="1" style="width:40px;">
            </label>
            <label>
              Светлые:
              <input type="number" id="lightCount" min="0" max="9" value="1" style="width:40px;">
            </label>
          </div>
          <label>
            Смягчение масок:
            <input type="range" id="maskBlur" min="0" max="20" step="0.1" value="0" style="width:100px;">
            <input type="number" id="maskBlurInput" min="0" max="20" step="0.1" value="0" style="width:40px;">
          </label>
        </div>
        <div id="palette" class="palette"></div>
        <div id="pipetteOverlay" style="display:none;position:fixed;z-index:9999;top:0;left:0;width:100vw;height:100vh;background:rgba(0,0,0,0.85);justify-content:center;align-items:center;">
          <img id="pipetteImg" style="max-width:90vw;max-height:90vh;box-shadow:0 0 0 4px #fff;cursor:crosshair;"/>
        </div>
        <div id="colorMaps" style="margin-top:10px;display:flex;flex-wrap:wrap;gap:10px;"></div>
      </div>

      <!-- 4) -->
      <div id="actualColorsSection" class="second-preview">
        <div class="preview-label">4) Сопоставление с фактическими цветами</div>
        <div class="settings">
          <label>
            Фактическая палитра (доступные цвета):
            <button id="addColorBtn" type="button" style="margin-left:10px;padding:4px 8px;background:var(--accent);border:none;border-radius:4px;color:#081018;cursor:pointer;">+ Добавить цвет</button>
          </label>
          <div id="actualPalette" class="palette" style="margin-top:10px;">
            <!-- Фактические цвета будут добавляться здесь -->
          </div>
          <div style="margin-top:15px;">
            <label>
              <input type="checkbox" id="syncWithCalculated" checked> Соответствие расчётной палитре
            </label>
            <label style="margin-left:15px;">
              <input type="checkbox" id="autoMatchColors" checked> Автоматическое сопоставление
            </label>
            <button id="syncPaletteBtn" type="button" style="margin-left:10px;padding:6px 12px;background:var(--accent);border:none;border-radius:6px;color:#081018;cursor:pointer;">Синхронизировать</button>
            <button id="matchColorsBtn" type="button" style="margin-left:10px;padding:6px 12px;background:var(--accent);border:none;border-radius:6px;color:#081018;cursor:pointer;">Сопоставить цвета</button>
          </div>
        </div>
        <div id="colorMapping" style="margin-top:15px;padding:10px;background:rgba(255,255,255,0.05);border-radius:8px;">
          <h4 style="margin:0 0 10px 0;">Сопоставление цветов:</h4>
          <div id="mappingList">
            <!-- Список сопоставлений будет здесь -->
          </div>
        </div>
        <div id="actualColorMaps" style="margin-top:15px;">
          <h4 style="margin:0 0 10px 0;">Маски с фактическими цветами: <span id="usedColorsInfo" style="font-size:12px;color:var(--muted);font-weight:normal;"></span></h4>
          <div id="actualMapsContainer" style="display:flex;flex-wrap:wrap;gap:10px;"></div>
        </div>
      </div>

      <!-- 5) -->
      <div id="stringartSection" class="second-preview">
        <div class="preview-label">5) Настройки StringArt</div>
        <div class="settings">
          <label>
            Форма полотна:
            <select id="canvasShape">
              <option value="circle" selected>Круглый</option>
              <option value="square">Квадратный</option>
            </select>
          </label>
          <label>
            Размер полотна:
            <select id="canvasSize">
              <option value="30" selected>30 см</option>
            </select>
          </label>
          <label>
            Количество гвоздей:
            <input type="number" id="nailCount" min="50" max="500" value="200" style="width:80px;">
          </label>
        </div>
        <div id="stringartPreview" style="margin-top:15px;text-align:center;">
          <h4 style="margin:0 0 10px 0;">Схема полотна:</h4>
          <canvas id="stringartCanvas" style="background:transparent;max-width:100%;height:auto;"></canvas>
          <div id="stringartInfo" style="margin-top:10px;font-size:12px;color:var(--muted);">
            Размер: 30 см | Гвоздей: 200 | Расстояние между гвоздями: ~0.47 см
          </div>
        </div>
      </div>
    </section>
  </main>
</div>

<script>
// =========================
// Этот скрипт реализует работу мини-приложения для Telegram,
// которое позволяет выбрать или сделать фото, изменить его размер и размытость,
// а также получить палитру основных цветов и построить цветовые карты.
// =========================

// Создаём скрытый input для загрузки файла изображения
const fileInput=document.createElement('input');
fileInput.type='file'; // Тип input — файл
fileInput.accept='image/*'; // Принимаются только изображения
fileInput.capture='environment'; // Открывать камеру по умолчанию на мобильных
fileInput.style.display='none'; // Скрываем элемент
// Добавляем input на страницу
document.body.appendChild(fileInput);

// Получаем ссылки на все нужные элементы интерфейса по их id
const uploadBtn=document.getElementById('uploadBtn'); // Кнопка "Выбрать файл"
const cameraBtn=document.getElementById('cameraBtn'); // Кнопка "Сделать фото"
const resetBtn=document.getElementById('resetBtn'); // Кнопка "Сброс"
const preview=document.getElementById('preview'); // Блок предпросмотра
const previewImg=document.getElementById('previewImg'); // Картинка предпросмотра
const cameraStream=document.getElementById('cameraStream'); // Видео с камеры
const snapshotCanvas=document.getElementById('snapshotCanvas'); // Канвас для снимка
const resolutionRange=document.getElementById('resolutionRange'); // Слайдер ширины
const resolutionInput=document.getElementById('resolutionInput'); // Поле ширины
const percentDisplay=document.getElementById('percentDisplay'); // Отображение процента
const secondPreview=document.getElementById('secondPreview'); // Блок изменённого изображения
const secondImg=document.getElementById('secondImg'); // Изменённое изображение
const blurRange=document.getElementById('blurRange'); // Слайдер размытия
const blurInput=document.getElementById('blurInput'); // Поле размытия
const paletteSection=document.getElementById('paletteSection'); // Блок палитры
const clusteringMethod=document.getElementById('clusteringMethod'); // Метод кластеризации
const colorCount=document.getElementById('colorCount'); // Количество цветов
const paletteDiv=document.getElementById('palette'); // Палитра цветов
const colorMaps=document.getElementById('colorMaps'); // Блок для цветовых карт

// Настройки для разных методов
const kmeansSettings=document.getElementById('kmeansSettings');
const tonesSettings=document.getElementById('tonesSettings');
const minDeltaEInput=document.getElementById('minDeltaE');
const darkCount=document.getElementById('darkCount');
const midCount=document.getElementById('midCount');
const lightCount=document.getElementById('lightCount');

// Получаем ссылки на новые элементы
const maskBlur = document.getElementById('maskBlur');
const maskBlurInput = document.getElementById('maskBlurInput');

// Элементы для работы с фактическими цветами
const actualColorsSection = document.getElementById('actualColorsSection');
const addColorBtn = document.getElementById('addColorBtn');
const actualPaletteDiv = document.getElementById('actualPalette');
const syncWithCalculated = document.getElementById('syncWithCalculated');
const autoMatchColors = document.getElementById('autoMatchColors');
const syncPaletteBtn = document.getElementById('syncPaletteBtn');
const matchColorsBtn = document.getElementById('matchColorsBtn');
const mappingList = document.getElementById('mappingList');
const actualMapsContainer = document.getElementById('actualMapsContainer');
const usedColorsInfo = document.getElementById('usedColorsInfo');

// Элементы для StringArt
const stringartSection = document.getElementById('stringartSection');
const canvasShape = document.getElementById('canvasShape');
const canvasSize = document.getElementById('canvasSize');
const nailCount = document.getElementById('nailCount');
const stringartCanvas = document.getElementById('stringartCanvas');
const stringartInfo = document.getElementById('stringartInfo');
// Синхронизация слайдера и поля (обновляем только обычные маски)
maskBlur.addEventListener('input',()=>{maskBlurInput.value=maskBlur.value;generateColorMaps();});
maskBlurInput.addEventListener('input',()=>{maskBlur.value=maskBlurInput.value;generateColorMaps();});

// Переменные для хранения исходного изображения и палитры
let originalImage=null,originalWidth=0,currentPalette=[];
let actualPalette=[]; // Фактическая палитра доступных цветов
let colorMapping=[]; // Сопоставление расчётных цветов с фактическими

// === ФОН ===
const backgroundSettings = document.getElementById('backgroundSettings');
const bgColorPicker = document.getElementById('bgColorPicker');
const bgPipetteBtn = document.getElementById('bgPipetteBtn');
const currentBgColor = document.getElementById('currentBgColor');
let backgroundColor = '#ffffff'; // по умолчанию

// Функция для обновления отображения текущего цвета фона
function updateBgColorDisplay(hex) {
  console.log('updateBgColorDisplay вызвана с hex:', hex);
  currentBgColor.textContent = hex;
  currentBgColor.style.background = hex;
  if (bgColorPicker) {
    console.log('Обновляем bgColorPicker.value на:', hex);
    bgColorPicker.value = hex;
  } else {
    console.log('bgColorPicker не найден!');
  }
}

// Функция для установки цвета фона
function setBackgroundColor(hex) {
  console.log('setBackgroundColor вызвана с hex:', hex);
  backgroundColor = hex;
  updateBgColorDisplay(hex);
}

// Обработчик выбора предустановленных цветов
backgroundSettings.querySelectorAll('.color-circle').forEach(btn => {
  btn.addEventListener('click', () => {
    setBackgroundColor(btn.getAttribute('data-bg'));
  });
});

// Обработчик палитры
bgColorPicker.addEventListener('input', e => {
  setBackgroundColor(e.target.value);
});

// --- Автоматическое определение цвета фона по краям изображения ---
// Получаем ссылку на поле процента
const bgEdgePercent = document.getElementById('bgEdgePercent');

function getAverageEdgeColor(img) {
  const canvas = document.createElement('canvas');
  canvas.width = img.naturalWidth || img.width;
  canvas.height = img.naturalHeight || img.height;
  const ctx = canvas.getContext('2d');
  ctx.drawImage(img, 0, 0);
  const w = canvas.width, h = canvas.height;
  const imageData = ctx.getImageData(0, 0, w, h).data;
  let r = 0, g = 0, b = 0, count = 0;
  // Получаем процент из поля, ограничиваем от 1 до 100
  let percent = 10;
  if (typeof bgEdgePercent !== 'undefined' && bgEdgePercent) {
    percent = Math.max(1, Math.min(100, parseInt(bgEdgePercent.value) || 10));
  }
  const edgeY = Math.max(1, Math.round(h * percent / 100)); // % от высоты
  const edgeX = Math.max(1, Math.round(w * percent / 100)); // % от ширины
  // Верхняя полоса
  for (let y = 0; y < edgeY; y++) {
    for (let x = 0; x < w; x++) {
      let iTop = (y * w + x) * 4;
      r += imageData[iTop]; g += imageData[iTop + 1]; b += imageData[iTop + 2];
      count++;
    }
  }
  // Левая и правая полосы (без углов, чтобы не дублировать)
  for (let x = 0; x < edgeX; x++) {
    for (let y = edgeY; y < h - edgeY; y++) {
      let iLeft = (y * w + x) * 4;
      let iRight = (y * w + (w - 1 - x)) * 4;
      r += imageData[iLeft]; g += imageData[iLeft + 1]; b += imageData[iLeft + 2];
      r += imageData[iRight]; g += imageData[iRight + 1]; b += imageData[iRight + 2];
      count += 2;
    }
  }
  r = Math.round(r / count);
  g = Math.round(g / count);
  b = Math.round(b / count);
  return rgbToHex(r, g, b);
}

function rgbToHex(r, g, b) {
  return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
}

// При изменении процента — пересчитываем цвет фона, если изображение есть
if (bgEdgePercent) {
  function recalcBgColorByPercent() {
    console.log('recalcBgColorByPercent вызвана');
    console.log('previewImg:', previewImg);
    console.log('previewImg.src:', previewImg ? previewImg.src : 'нет');
    console.log('previewImg.complete:', previewImg ? previewImg.complete : 'нет');
    console.log('previewImg.naturalWidth:', previewImg ? previewImg.naturalWidth : 'нет');
    if (previewImg && previewImg.src && previewImg.complete && previewImg.naturalWidth > 0) {
      const hex = getAverageEdgeColor(previewImg);
      setBackgroundColor(hex);
    } else {
      console.log('Условия для пересчёта цвета фона не выполнены');
    }
  }
  bgEdgePercent.addEventListener('input', recalcBgColorByPercent);
  bgEdgePercent.addEventListener('change', recalcBgColorByPercent);
}

// После загрузки изображения определяем цвет фона автоматически
function autoDetectBg(img) {
  const hex = getAverageEdgeColor(img);
  setBackgroundColor(hex);
}

// --- Функция для загрузки тестового изображения по умолчанию ---
function loadDefaultImage() {
  const defaultImgUrl = 'https://sun9-83.userapi.com/s/v1/ig1/XJRPO-T4RuE0KFMctnOM20rCs68dYcO4H5KnFW6s5E_x1BlQhkN2lojil1AW11LQ6xGG1uKa.jpg?quality=96&as=32x40,48x60,72x90,108x135,160x200,240x300,360x449,480x599,540x674,640x799,720x899,865x1080&from=bu&cs=865x0';
  const img = new Image();
  img.crossOrigin = 'Anonymous'; // Важно для работы с canvas!
  img.onload = () => {
    // Копируем изображение в canvas и получаем dataURL
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = img.width;
    tempCanvas.height = img.height;
    const ctx = tempCanvas.getContext('2d');
    ctx.drawImage(img, 0, 0);
    const dataURL = tempCanvas.toDataURL('image/png');
    previewImg.src = dataURL;
    preview.classList.add('active');
    originalImage = dataURL;
    originalWidth = img.width;
    uploadBtn.style.display = '';
    cameraBtn.style.display = '';
    resetBtn.style.display = '';
    resolutionRange.max = img.width;
    resolutionInput.max = img.width;
    resolutionRange.value = img.width * 0.2;
    resolutionInput.value = img.width * 0.2;
    percentDisplay.textContent = '20%';
    applyResolution();
    autoDetectBg(img); // <--- определяем фон
  };
  img.src = defaultImgUrl;
}
// --- Загружаем тестовое изображение при старте ---
window.addEventListener('DOMContentLoaded', () => {
  loadDefaultImage();
  updateMethodInterface(); // Инициализируем интерфейс для выбранного метода
});

// Обработчик кнопки "Выбрать файл" — открывает диалог выбора файла
uploadBtn.addEventListener('click',()=>fileInput.click());
// Когда выбран файл, вызываем функцию обработки файла
fileInput.addEventListener('change',()=>{const f=fileInput.files?.[0];if(f)handleFile(f);});

// Обработчик кнопки "Сброс" — возвращает приложение в исходное состояние
resetBtn.addEventListener('click',()=>{
  fileInput.value='';
  previewImg.removeAttribute('src');
  preview.classList.remove('active');
  secondImg.removeAttribute('src');
  secondPreview.classList.remove('active');
  paletteSection.classList.remove('active');
  colorMaps.innerHTML='';
  actualColorsSection.classList.remove('active');
  actualMapsContainer.innerHTML='';
  mappingList.innerHTML='';
  actualPalette = [];
  colorMapping = [];
  renderActualPalette(); // Обновляем отображение фактической палитры
  stringartSection.classList.remove('active');
  cameraStream.style.display='none';
  resetBtn.style.display='none';
  uploadBtn.style.display='';
  cameraBtn.style.display='';
  resolutionRange.value=200;resolutionInput.value=200;percentDisplay.textContent='20%';
  blurRange.value=0;blurInput.value=0;
  originalImage=null;originalWidth=0;
  // После сброса снова показываем тестовое изображение
  loadDefaultImage();
  updateMethodInterface(); // Обновляем интерфейс после сброса
});

// Обработчик кнопки "Сделать фото" — включает камеру и делает снимок через 3 секунды
cameraBtn.addEventListener('click',async()=>{
  try{
    const stream=await navigator.mediaDevices.getUserMedia({video:true}); // Запрашиваем доступ к камере
    cameraStream.srcObject=stream;cameraStream.style.display='block'; // Показываем видео
    setTimeout(()=>takeSnapshot(stream),3000); // Через 3 секунды делаем снимок
  }catch(err){alert('Не удалось открыть камеру:'+err);}
});

// Функция делает снимок с камеры и отображает его
function takeSnapshot(stream){
  const ctx=snapshotCanvas.getContext('2d');
  snapshotCanvas.width=cameraStream.videoWidth;
  snapshotCanvas.height=cameraStream.videoHeight;
  ctx.drawImage(cameraStream,0,0); // Копируем изображение с видео на канвас
  const dataURL=snapshotCanvas.toDataURL('image/png'); // Получаем картинку в виде строки
  previewImg.src=dataURL;preview.classList.add('active'); // Показываем предпросмотр
  originalImage=dataURL;originalWidth=cameraStream.videoWidth; // Сохраняем данные
  cameraStream.style.display='none';stream.getTracks().forEach(t=>t.stop()); // Отключаем камеру
  uploadBtn.style.display='none';cameraBtn.style.display='none';resetBtn.style.display=''; // Меняем кнопки
  resolutionRange.value=originalWidth*0.2;resolutionInput.value=originalWidth*0.2;percentDisplay.textContent='20%'; // Ставим ширину 20%
  applyResolution(); // Применяем изменения
}

// Функция обработки выбранного файла изображения
function handleFile(file){
  if(!file||!file.type.startsWith('image/')){
    // Если файл не выбран или не является изображением, ничего не делаем
    return;
  }
  const r = new FileReader();
  r.onload = () => {
    const img = new Image();
    img.onload = () => {
      previewImg.src = r.result;
      preview.classList.add('active');
      originalImage = r.result;
      originalWidth = img.width;
      uploadBtn.style.display = 'none';
      cameraBtn.style.display = 'none';
      resetBtn.style.display = '';
      resolutionRange.max = img.width;
      resolutionInput.max = img.width;
      resolutionRange.value = img.width * 0.2;
      resolutionInput.value = img.width * 0.2;
      percentDisplay.textContent = '20%';
      applyResolution();
      autoDetectBg(img); // <--- определяем фон
    };
    img.src = r.result;
  };
  r.readAsDataURL(file);
}

// Функция обновляет отображение процента ширины
function updatePercent(){
  percentDisplay.textContent=Math.round((resolutionInput.value/originalWidth)*100)+'%';
}

// Обработчики изменения ширины и размытия изображения
resolutionRange.addEventListener('input',()=>{resolutionInput.value=resolutionRange.value;updatePercent();applyResolution();});
resolutionInput.addEventListener('input',()=>{resolutionRange.value=resolutionInput.value;updatePercent();applyResolution();});
blurRange.addEventListener('input',()=>{blurInput.value=blurRange.value;applyResolution();});
blurInput.addEventListener('input',()=>{blurRange.value=blurInput.value;applyResolution();});

// Функция применяет выбранную ширину и размытие к изображению
function applyResolution(){
  if(!originalImage)return;
  const img=new Image();
  img.onload=()=>{
    const newWidth=parseInt(resolutionInput.value);const scale=newWidth/originalWidth;
    const ctx=snapshotCanvas.getContext('2d');
    snapshotCanvas.width=newWidth;snapshotCanvas.height=img.height*scale;
    ctx.filter=`blur(${blurInput.value}px)`;ctx.drawImage(img,0,0,snapshotCanvas.width,snapshotCanvas.height);
    ctx.filter='';
    secondImg.onload = () => {
      secondPreview.classList.add('active');
      paletteSection.classList.add('active');
      extractPalette(); // теперь палитра строится по реально обновлённому изображению
    };
    secondImg.src=snapshotCanvas.toDataURL('image/png');
    secondImg.style.width='100%';
  };
  img.src=originalImage;
}

// ======= Палитра с выбором метода кластеризации =======

// Функция для переключения интерфейса в зависимости от выбранного метода
function updateMethodInterface() {
  const method = clusteringMethod.value;
  
  if (method === 'kmeans') {
    kmeansSettings.style.display = 'none';
    tonesSettings.style.display = 'none';
  } else if (method === 'tones') {
    kmeansSettings.style.display = 'none';
    tonesSettings.style.display = 'block';
    // Автоматически настраиваем пропорции при переключении на метод по тонам
    updateTonesProportions();
  }
}

// Функция для обновления общего количества цветов в методе по тонам
function updateTonesColorCount() {
  const darkN = parseInt(darkCount.value) || 0;
  const midN = parseInt(midCount.value) || 0;
  const lightN = parseInt(lightCount.value) || 0;
  const total = darkN + midN + lightN;
  
  if (total > 0) {
    colorCount.value = total;
  }
}

// Функция для автоматической настройки пропорций при изменении общего количества цветов
function updateTonesProportions() {
  const total = parseInt(colorCount.value) || 3;
  const perGroup = Math.floor(total / 3);
  const remainder = total % 3;
  
  // Распределяем поровну, остаток добавляем к средним тонам
  darkCount.value = perGroup;
  midCount.value = perGroup + remainder;
  lightCount.value = perGroup;
}
// Функция переводит цвет из RGB в LAB (для сравнения различия цветов)
function rgbToLab(r,g,b){function pivot(n){return n>0.008856?Math.pow(n,1/3):(7.787*n)+(16/116);}
  r/=255;g/=255;b/=255;
  r=r>0.04045?Math.pow((r+0.055)/1.055,2.4):r/12.92;
  g=g>0.04045?Math.pow((g+0.055)/1.055,2.4):g/12.92;
  b=b>0.04045?Math.pow((b+0.055)/1.055,2.4):b/12.92;
  let x=(r*0.4124+g*0.3576+b*0.1805)/0.95047;
  let y=(r*0.2126+g*0.7152+b*0.0722)/1.000;
  let z=(r*0.0193+g*0.1192+b*0.9505)/1.08883;
  x=pivot(x);y=pivot(y);z=pivot(z);
  return[(116*y)-16,500*(x-y),200*(y-z)];
}

// Функция считает "различие" между двумя цветами в LAB
function deltaE(a,b){return Math.sqrt((a[0]-b[0])**2+(a[1]-b[1])**2+(a[2]-b[2])**2);}

// Функция для инициализации центроидов k-means
function initializeCentroids(colors, k) {
  const centroids = [];
  // Выбираем случайные цвета как начальные центроиды
  for (let i = 0; i < k; i++) {
    const randomIndex = Math.floor(Math.random() * colors.length);
    centroids.push([...colors[randomIndex]]);
  }
  return centroids;
}

// Функция для нахождения ближайшего центроида
function findNearestCentroid(color, centroids) {
  let minDistance = Infinity;
  let nearestIndex = 0;
  
  for (let i = 0; i < centroids.length; i++) {
    const distance = deltaE(rgbToLab(...color), rgbToLab(...centroids[i]));
    if (distance < minDistance) {
      minDistance = distance;
      nearestIndex = i;
    }
  }
  
  return nearestIndex;
}

// Функция для вычисления нового центроида (среднего цвета кластера)
function calculateNewCentroid(cluster) {
  if (cluster.length === 0) return [0, 0, 0];
  
  const sumR = cluster.reduce((sum, color) => sum + color[0], 0);
  const sumG = cluster.reduce((sum, color) => sum + color[1], 0);
  const sumB = cluster.reduce((sum, color) => sum + color[2], 0);
  
  return [
    Math.round(sumR / cluster.length),
    Math.round(sumG / cluster.length),
    Math.round(sumB / cluster.length)
  ];
}

// Основная функция k-means алгоритма
function kMeansClustering(colors, k, maxIterations = 100) {
  // Инициализируем центроиды
  let centroids = initializeCentroids(colors, k);
  let clusters = Array(k).fill().map(() => []);
  let iterations = 0;
  
  while (iterations < maxIterations) {
    // Очищаем кластеры
    clusters = Array(k).fill().map(() => []);
    
    // Распределяем цвета по кластерам
    for (const color of colors) {
      const nearestIndex = findNearestCentroid(color, centroids);
      clusters[nearestIndex].push(color);
    }
    
    // Вычисляем новые центроиды
    const newCentroids = clusters.map(cluster => calculateNewCentroid(cluster));
    
    // Проверяем, изменились ли центроиды
    let centroidsChanged = false;
    for (let i = 0; i < k; i++) {
      if (deltaE(rgbToLab(...centroids[i]), rgbToLab(...newCentroids[i])) > 1) {
        centroidsChanged = true;
        break;
      }
    }
    
    if (!centroidsChanged) break;
    
    centroids = newCentroids;
    iterations++;
  }
  
  return centroids;
}

// Функция для фильтрации цветов по минимальной разнице (ΔE)
function filterColorsByDeltaE(colors, minDeltaE) {
  let res = [];
  colors.forEach(c => {
    let lab = rgbToLab(c[0], c[1], c[2]);
    if (!res.some(r => deltaE(lab, r.lab) < minDeltaE)) {
      res.push({rgb: c, lab});
    }
  });
  return res.map(r => r.rgb);
}

// Функция для кластеризации по тонам (старый подход)
function clusterByTones(colors) {
  // Сортируем по яркости (L из LAB)
  let colorsWithL = colors.map(rgb => {
    let lab = rgbToLab(rgb[0], rgb[1], rgb[2]);
    return {rgb, L: lab[0]};
  });
  colorsWithL.sort((a, b) => a.L - b.L);
  
  // Разбиваем на 3 группы: тёмные, средние, светлые
  let n = colorsWithL.length;
  let borders = [Math.floor(n/3), Math.floor(2*n/3)];
  let groups = [[], [], []];
  
  for (let i = 0; i < n; i++) {
    if (i < borders[0]) groups[0].push(colorsWithL[i].rgb);
    else if (i < borders[1]) groups[1].push(colorsWithL[i].rgb);
    else groups[2].push(colorsWithL[i].rgb);
  }
  
  // Получаем желаемое количество из каждой группы
  let darkN = parseInt(darkCount.value) || 0;
  let midN = parseInt(midCount.value) || 0;
  let lightN = parseInt(lightCount.value) || 0;
  
  // В каждой группе выбираем отличающиеся цвета
  let uniq = [];
  let filteredDark = filterColorsByDeltaE(groups[0], parseInt(minDeltaEInput.value));
  let filteredMid = filterColorsByDeltaE(groups[1], parseInt(minDeltaEInput.value));
  let filteredLight = filterColorsByDeltaE(groups[2], parseInt(minDeltaEInput.value));
  
  uniq = uniq.concat(filteredDark.slice(0, darkN));
  uniq = uniq.concat(filteredMid.slice(0, midN));
  uniq = uniq.concat(filteredLight.slice(0, lightN));
  
  return uniq;
}

// ======= Функции для работы с фактическими цветами =======

// Функция для синхронизации фактической палитры с расчётной
function syncActualWithCalculated() {
  if (syncWithCalculated.checked && currentPalette.length > 0) {
    actualPalette = [...currentPalette]; // Копируем расчётную палитру
    renderActualPalette();
    if (autoMatchColors.checked) {
      matchColors();
    }
  }
}

// Функция для добавления цвета в фактическую палитру
function addActualColor(color = '#ffffff') {
  actualPalette.push(color);
  renderActualPalette();
  if (autoMatchColors.checked) {
    matchColors();
  }
}

// Функция для удаления цвета из фактической палитры
function removeActualColor(index) {
  actualPalette.splice(index, 1);
  renderActualPalette();
  if (autoMatchColors.checked) {
    matchColors();
  }
}

// Функция для отображения фактической палитры
function renderActualPalette() {
  actualPaletteDiv.innerHTML = '';
  actualPalette.forEach((color, index) => {
    const item = document.createElement('div');
    item.className = 'color-item actual-color-item';
    
    const circle = document.createElement('input');
    circle.type = 'color';
    circle.value = color;
    circle.className = 'color-circle';
    
    const code = document.createElement('input');
    code.type = 'text';
    code.value = color;
    code.className = 'color-code';
    code.maxLength = 7;
    
    const removeBtn = document.createElement('button');
    removeBtn.innerHTML = '×';
    removeBtn.className = 'remove-color-btn';
    removeBtn.title = 'Удалить цвет';
    removeBtn.onclick = () => removeActualColor(index);
    
    // События для изменения цвета
    circle.addEventListener('input', () => {
      code.value = circle.value;
      actualPalette[index] = circle.value;
      if (autoMatchColors.checked) {
        matchColors();
      }
      updateStringartPreview();
    });
    
    code.addEventListener('input', () => {
      circle.value = code.value;
      actualPalette[index] = code.value;
      if (autoMatchColors.checked) {
        matchColors();
      }
      updateStringartPreview();
    });
    
    item.appendChild(circle);
    item.appendChild(code);
    item.appendChild(removeBtn);
    actualPaletteDiv.appendChild(item);
  });
}

// Функция для сопоставления расчётных цветов с фактическими
function matchColors() {
  if (currentPalette.length === 0 || actualPalette.length === 0) {
    colorMapping = [];
    renderColorMapping();
    generateActualColorMaps();
    return;
  }
  
  colorMapping = [];
  
  // Для каждого расчётного цвета находим ближайший фактический
  currentPalette.forEach((calculatedColor, index) => {
    const calculatedRGB = hexToRgb(calculatedColor);
    const calculatedLAB = rgbToLab(calculatedRGB[0], calculatedRGB[1], calculatedRGB[2]);
    
    let bestMatch = null;
    let bestDistance = Infinity;
    
    actualPalette.forEach((actualColor, actualIndex) => {
      const actualRGB = hexToRgb(actualColor);
      const actualLAB = rgbToLab(actualRGB[0], actualRGB[1], actualRGB[2]);
      const distance = deltaE(calculatedLAB, actualLAB);
      
      if (distance < bestDistance) {
        bestDistance = distance;
        bestMatch = {
          actualColor: actualColor,
          actualIndex: actualIndex,
          distance: distance
        };
      }
    });
    
    colorMapping.push({
      calculatedColor: calculatedColor,
      calculatedIndex: index,
      actualColor: bestMatch.actualColor,
      actualIndex: bestMatch.actualIndex,
      distance: bestMatch.distance
    });
  });
  
  renderColorMapping();
  generateActualColorMaps();
  updateStringartPreview();
}

// Функция для отображения сопоставления цветов
function renderColorMapping() {
  mappingList.innerHTML = '';
  
  if (colorMapping.length === 0) {
    mappingList.innerHTML = '<p style="color:var(--muted);margin:0;">Нет данных для сопоставления</p>';
    return;
  }
  
  colorMapping.forEach((mapping, index) => {
    const item = document.createElement('div');
    item.className = 'mapping-item';
    
    const colorsDiv = document.createElement('div');
    colorsDiv.className = 'mapping-colors';
    
    // Расчётный цвет
    const calculatedDiv = document.createElement('div');
    calculatedDiv.style.display = 'flex';
    calculatedDiv.style.alignItems = 'center';
    calculatedDiv.style.gap = '8px';
    
    const calculatedCircle = document.createElement('div');
    calculatedCircle.style.width = '24px';
    calculatedCircle.style.height = '24px';
    calculatedCircle.style.borderRadius = '50%';
    calculatedCircle.style.backgroundColor = mapping.calculatedColor;
    calculatedCircle.style.border = '2px solid #fff';
    
    const calculatedLabel = document.createElement('span');
    calculatedLabel.textContent = `Расчётный ${index + 1}`;
    calculatedLabel.style.fontSize = '12px';
    
    calculatedDiv.appendChild(calculatedCircle);
    calculatedDiv.appendChild(calculatedLabel);
    
    // Стрелка
    const arrow = document.createElement('span');
    arrow.className = 'mapping-arrow';
    arrow.textContent = '→';
    
    // Фактический цвет
    const actualDiv = document.createElement('div');
    actualDiv.style.display = 'flex';
    actualDiv.style.alignItems = 'center';
    actualDiv.style.gap = '8px';
    
    const actualCircle = document.createElement('div');
    actualCircle.style.width = '24px';
    actualCircle.style.height = '24px';
    actualCircle.style.borderRadius = '50%';
    actualCircle.style.backgroundColor = mapping.actualColor;
    actualCircle.style.border = '2px solid #fff';
    
    const actualLabel = document.createElement('span');
    actualLabel.textContent = `Фактический ${mapping.actualIndex + 1}`;
    actualLabel.style.fontSize = '12px';
    
    actualDiv.appendChild(actualCircle);
    actualDiv.appendChild(actualLabel);
    
    // Расстояние
    const distanceLabel = document.createElement('span');
    distanceLabel.textContent = `ΔE: ${mapping.distance.toFixed(1)}`;
    distanceLabel.style.fontSize = '11px';
    distanceLabel.style.color = 'var(--muted)';
    
    colorsDiv.appendChild(calculatedDiv);
    colorsDiv.appendChild(arrow);
    colorsDiv.appendChild(actualDiv);
    colorsDiv.appendChild(distanceLabel);
    
    item.appendChild(colorsDiv);
    mappingList.appendChild(item);
  });
}

// Функция для генерации масок с фактическими цветами
function generateActualColorMaps() {
  actualMapsContainer.innerHTML = '';
  
  if (!secondImg.src || colorMapping.length === 0) {
    usedColorsInfo.textContent = '';
    return;
  }
  
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  canvas.width = secondImg.naturalWidth;
  canvas.height = secondImg.naturalHeight;
  ctx.drawImage(secondImg, 0, 0);
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const data = imageData.data;
  
  // Переводим цвета палитры из HEX в RGB
  const calculatedRGB = currentPalette.map(hex => {
    const bigint = parseInt(hex.slice(1), 16);
    return [(bigint >> 16) & 255, (bigint >> 8) & 255, (bigint) & 255];
  });
  
  // Получаем уникальные индексы фактических цветов, которые используются в сопоставлении
  const usedActualIndices = [...new Set(colorMapping.map(m => m.actualIndex))];
  
  // Обновляем информацию об использованных цветах
  usedColorsInfo.textContent = `(используется ${usedActualIndices.length} из ${actualPalette.length} цветов)`;
  
  // Создаём маски только для фактических цветов, которые используются в сопоставлении
  usedActualIndices.forEach(actualIndex => {
    const actualColor = actualPalette[actualIndex];
    const mapCanvas = document.createElement('canvas');
    const mapCtx = mapCanvas.getContext('2d');
    mapCanvas.width = canvas.width;
    mapCanvas.height = canvas.height;
    const mapImageData = mapCtx.createImageData(canvas.width, canvas.height);
    const mapData = mapImageData.data;
    
    for (let i = 0; i < data.length; i += 4) {
      const r = data[i], g = data[i + 1], b = data[i + 2];
      
      // Находим ближайший расчётный цвет
      const distances = calculatedRGB.map(c => Math.sqrt((r - c[0]) ** 2 + (g - c[1]) ** 2 + (b - c[2]) ** 2));
      const minIndex = distances.indexOf(Math.min(...distances));
      
      // Проверяем, сопоставлен ли этот расчётный цвет с текущим фактическим
      const mapping = colorMapping.find(m => m.calculatedIndex === minIndex);
      if (mapping && mapping.actualIndex === actualIndex) {
        mapData[i] = 0;     // Чёрный пиксель
        mapData[i + 1] = 0;
        mapData[i + 2] = 0;
        mapData[i + 3] = 255;
      } else {
        mapData[i] = 255;   // Белый пиксель
        mapData[i + 1] = 255;
        mapData[i + 2] = 255;
        mapData[i + 3] = 255;
      }
    }
    
    // Применяем размытие к маске, если нужно
    let blurValue = parseInt(maskBlur.value) || 0;
    if (blurValue > 0) {
      mapCtx.putImageData(mapImageData, 0, 0);
      mapCtx.filter = `blur(${blurValue}px)`;
      mapCtx.drawImage(mapCanvas, 0, 0);
      mapCtx.filter = '';
      const blurred = mapCtx.getImageData(0, 0, mapCanvas.width, mapCanvas.height);
      mapCtx.putImageData(blurred, 0, 0);
    } else {
      mapCtx.putImageData(mapImageData, 0, 0);
    }
    
    const img = document.createElement('img');
    img.src = mapCanvas.toDataURL();
    img.style.border = `4px solid ${actualColor}`;
    actualMapsContainer.appendChild(img);
  });
}

// ======= Функции для StringArt =======

// Функция для генерации схемы StringArt
function generateStringartPreview() {
  const shape = canvasShape.value;
  const size = parseInt(canvasSize.value);
  const nails = parseInt(nailCount.value);
  
  // Размеры canvas для отображения (масштаб 1 см = 10 пикселей)
  const canvasWidth = 310; // 31 см * 10 пикселей/см
  const canvasHeight = 310;
  
  // Настройка canvas
  stringartCanvas.width = canvasWidth;
  stringartCanvas.height = canvasHeight;
  const ctx = stringartCanvas.getContext('2d');
  
  // Очищаем canvas
  ctx.clearRect(0, 0, canvasWidth, canvasHeight);
  
  // Центр canvas
  const centerX = canvasWidth / 2;
  const centerY = canvasHeight / 2;
  
  // Радиус для отображения изображения (30 см = 300 пикселей)
  const imageRadius = 150; // 30 см / 2 * 10 пикселей/см
  
  // Радиус для отображения полотна (31 см = 310 пикселей)
  const canvasRadius = 155; // 31 см / 2 * 10 пикселей/см
  
  // Рисуем фон полотна (больший размер)
  ctx.fillStyle = '#e0e0e0';
  if (shape === 'circle') {
    ctx.beginPath();
    ctx.arc(centerX, centerY, canvasRadius, 0, 2 * Math.PI);
    ctx.fill();
  } else {
    const canvasSize = canvasRadius * 2;
    ctx.fillRect(centerX - canvasSize/2, centerY - canvasSize/2, canvasSize, canvasSize);
  }
  
  // Рисуем область изображения (меньший размер)
  ctx.fillStyle = '#cccccc';
  if (shape === 'circle') {
    ctx.beginPath();
    ctx.arc(centerX, centerY, imageRadius, 0, 2 * Math.PI);
    ctx.fill();
  } else {
    const imageSize = imageRadius * 2;
    ctx.fillRect(centerX - imageSize/2, centerY - imageSize/2, imageSize, imageSize);
  }
  
  // Рисуем гвозди
  ctx.fillStyle = '#000000';
  const nailRadius = 1.5; // Уменьшили размер гвоздиков в 2 раза
  
  for (let i = 0; i < nails; i++) {
    const angle = (i / nails) * 2 * Math.PI;
    
    let nailX, nailY;
    
    if (shape === 'circle') {
      // Гвозди по периметру круга (imageRadius)
      nailX = centerX + Math.cos(angle) * imageRadius;
      nailY = centerY + Math.sin(angle) * imageRadius;
    } else {
      // Для квадрата распределяем гвозди по периметру
      const sideLength = imageRadius * 2; // Длина стороны квадрата
      const perimeter = sideLength * 4; // Периметр квадрата
      const position = (i / nails) * perimeter;
      
      if (position < sideLength) {
        // Верхняя сторона (слева направо)
        nailX = centerX - imageRadius + position;
        nailY = centerY - imageRadius;
      } else if (position < 2 * sideLength) {
        // Правая сторона (сверху вниз)
        nailX = centerX + imageRadius;
        nailY = centerY - imageRadius + (position - sideLength);
      } else if (position < 3 * sideLength) {
        // Нижняя сторона (справа налево)
        nailX = centerX + imageRadius - (position - 2 * sideLength);
        nailY = centerY + imageRadius;
      } else {
        // Левая сторона (снизу вверх)
        nailX = centerX - imageRadius;
        nailY = centerY + imageRadius - (position - 3 * sideLength);
      }
    }
    
    ctx.beginPath();
    ctx.arc(nailX, nailY, nailRadius, 0, 2 * Math.PI);
    ctx.fill();
  }
  
  // Накладываем фактические маски, если они есть
  if (colorMapping.length > 0 && secondImg.src) {
    overlayActualMasks(ctx, centerX, centerY, imageRadius, shape);
  }
  
  // Обновляем информацию
  const imageSize = size; // Размер изображения (30 см)
  const actualSize = size + 1; // Фактический размер полотна с учётом отступа гвоздей (31 см)
  const perimeter = shape === 'circle' ? Math.PI * imageSize : 4 * imageSize; // Периметр изображения
  const nailDistance = perimeter / nails;
  
  stringartInfo.textContent = `Размер изображения: ${imageSize} см | Размер полотна: ${actualSize} см | Гвоздей: ${nails} | Расстояние между гвоздями: ~${nailDistance.toFixed(2)} см`;
}

// Функция для наложения фактических масок на схему StringArt
function overlayActualMasks(ctx, centerX, centerY, imageRadius, shape) {
  if (!secondImg.src || colorMapping.length === 0) return;
  
  // Создаём временный canvas для обработки изображения
  const tempCanvas = document.createElement('canvas');
  const tempCtx = tempCanvas.getContext('2d');
  tempCanvas.width = secondImg.naturalWidth;
  tempCanvas.height = secondImg.naturalHeight;
  
  // Рисуем исходное изображение
  tempCtx.drawImage(secondImg, 0, 0);
  const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
  const data = imageData.data;
  
  // Переводим цвета палитры из HEX в RGB
  const calculatedRGB = currentPalette.map(hex => {
    const bigint = parseInt(hex.slice(1), 16);
    return [(bigint >> 16) & 255, (bigint >> 8) & 255, (bigint) & 255];
  });
  
  // Размер области изображения в схеме
  const schemeImageSize = imageRadius * 2;
  
  // Создаём маску для каждой фактической палитры
  const usedActualIndices = [...new Set(colorMapping.map(m => m.actualIndex))];
  
  usedActualIndices.forEach(actualIndex => {
    const actualColor = actualPalette[actualIndex];
    const actualRGB = hexToRgb(actualColor);
    
    // Создаём маску для этого цвета
    const maskCanvas = document.createElement('canvas');
    const maskCtx = maskCanvas.getContext('2d');
    maskCanvas.width = tempCanvas.width;
    maskCanvas.height = tempCanvas.height;
    const maskImageData = maskCtx.createImageData(tempCanvas.width, tempCanvas.height);
    const maskData = maskImageData.data;
    
    for (let i = 0; i < data.length; i += 4) {
      const r = data[i], g = data[i + 1], b = data[i + 2];
      
      // Находим ближайший расчётный цвет
      const distances = calculatedRGB.map(c => Math.sqrt((r - c[0]) ** 2 + (g - c[1]) ** 2 + (b - c[2]) ** 2));
      const minIndex = distances.indexOf(Math.min(...distances));
      
      // Проверяем, сопоставлен ли этот расчётный цвет с текущим фактическим
      const mapping = colorMapping.find(m => m.calculatedIndex === minIndex);
      if (mapping && mapping.actualIndex === actualIndex) {
        // Этот пиксель должен быть окрашен в фактический цвет
        maskData[i] = actualRGB[0];
        maskData[i + 1] = actualRGB[1];
        maskData[i + 2] = actualRGB[2];
        maskData[i + 3] = 180; // Полупрозрачность
      } else {
        maskData[i + 3] = 0; // Прозрачный
      }
    }
    
    maskCtx.putImageData(maskImageData, 0, 0);
    
    // Накладываем маску на схему
    ctx.save();
    
    // Создаём обрезку по форме
    if (shape === 'circle') {
      ctx.beginPath();
      ctx.arc(centerX, centerY, imageRadius, 0, 2 * Math.PI);
      ctx.clip();
    } else {
      ctx.beginPath();
      ctx.rect(centerX - imageRadius, centerY - imageRadius, schemeImageSize, schemeImageSize);
      ctx.clip();
    }
    
    // Рисуем маску с масштабированием
    ctx.drawImage(maskCanvas, centerX - imageRadius, centerY - imageRadius, schemeImageSize, schemeImageSize);
    
    ctx.restore();
  });
}

// Вспомогательная функция для конвертации HEX в RGB
function hexToRgb(hex) {
  const bigint = parseInt(hex.slice(1), 16);
  return [(bigint >> 16) & 255, (bigint >> 8) & 255, (bigint) & 255];
}

// Извлекает палитру основных цветов из изображения используя выбранный метод
function extractPalette(){
 if(!secondImg.src)return;
 const canvas=document.createElement('canvas');const ctx=canvas.getContext('2d');
 canvas.width=secondImg.naturalWidth;canvas.height=secondImg.naturalHeight;
 ctx.drawImage(secondImg,0,0);
 const data=ctx.getImageData(0,0,canvas.width,canvas.height).data;
 
 // Собираем все цвета из изображения (каждый 4-й пиксель для производительности)
 let sampleColors=[];
 for(let i=0;i<data.length;i+=4*4){sampleColors.push([data[i],data[i+1],data[i+2]]);}
 
 const method = clusteringMethod.value;
 let resultColors = [];
 
 if (method === 'kmeans') {
   // Применяем k-means алгоритм для группировки пикселей по цветам
   let total = parseInt(colorCount.value) || 3;
   const centroids = kMeansClustering(sampleColors, total);
   resultColors = centroids;
 } else if (method === 'tones') {
   // Применяем кластеризацию по тонам
   resultColors = clusterByTones(sampleColors);
 }
 
 // Преобразуем цвета в HEX формат
 currentPalette = resultColors.map(c => '#' + ((1<<24)+(c[0]<<16)+(c[1]<<8)+c[2]).toString(16).slice(1));
 
 renderPalette();
 generateColorMaps();
 
 // Активируем 4-й раздел и обновляем сопоставление цветов
 actualColorsSection.classList.add('active');
 
 // Синхронизируем фактическую палитру с расчётной, если включена соответствующая галочка
 syncActualWithCalculated();
 
 // Обновляем отображение сопоставления
 renderActualPalette();
 
 // Активируем 5-й раздел и генерируем схему StringArt
 stringartSection.classList.add('active');
 generateStringartPreview();
}
// Отображает палитру на странице, позволяет менять цвета вручную
function renderPalette(){
  paletteDiv.innerHTML='';
  currentPalette.forEach((col,idx)=>{
    const item=document.createElement('div');item.className='color-item';
    const circle=document.createElement('input');circle.type='color';circle.value=col;circle.className='color-circle';
    const code=document.createElement('input');code.type='text';code.value=col;code.className='color-code';
    code.maxLength = 7;
    // Кнопка-пипетка
    const pipBtn=document.createElement('button');
    pipBtn.innerHTML='🖌️';
    pipBtn.title='Выбрать цвет с изображения';
    pipBtn.className='pipette-btn';
    pipBtn.addEventListener('click',function(e){
      e.stopPropagation();
      window.__activePipetteIndex = idx;
      pipetteImg.src = secondImg.src;
      pipetteOverlay.style.display = 'flex';
    });
    // События для circle и code
    circle.addEventListener('input',()=>{
      code.value=circle.value;
      currentPalette[idx]=circle.value;
      generateColorMaps();
      if (typeof syncWithCalculated !== 'undefined' && syncWithCalculated.checked) {
        syncActualWithCalculated();
      } else {
        renderActualPalette();
      }
    });
    code.addEventListener('input',()=>{
      circle.value=code.value;
      currentPalette[idx]=code.value;
      generateColorMaps();
      if (typeof syncWithCalculated !== 'undefined' && syncWithCalculated.checked) {
        syncActualWithCalculated();
      } else {
        renderActualPalette();
      }
    });
    // Строка управления значением и пипеткой
    const controls=document.createElement('div');
    controls.className='color-controls';
    controls.appendChild(code);
    controls.appendChild(pipBtn);
    // Сборка
    item.appendChild(circle);
    item.appendChild(controls);
    paletteDiv.appendChild(item);
  });
}
// Обработчики для переключения методов и обновления палитры
clusteringMethod.addEventListener('change', () => {
  updateMethodInterface();
  extractPalette();
});

// Обновляем палитру при изменении количества цветов
colorCount.addEventListener('change', () => {
  // Если выбран метод по тонам, автоматически настраиваем пропорции
  if (clusteringMethod.value === 'tones') {
    updateTonesProportions();
  }
  extractPalette();
});

// Обработчики для метода по тонам
minDeltaEInput.addEventListener('input', extractPalette);
darkCount.addEventListener('input', () => {
  // Обновляем общее количество только если сумма больше текущего значения
  const darkN = parseInt(darkCount.value) || 0;
  const midN = parseInt(midCount.value) || 0;
  const lightN = parseInt(lightCount.value) || 0;
  const total = darkN + midN + lightN;
  const currentTotal = parseInt(colorCount.value) || 0;
  
  if (total > currentTotal) {
    colorCount.value = total;
  }
  extractPalette();
});
midCount.addEventListener('input', () => {
  // Обновляем общее количество только если сумма больше текущего значения
  const darkN = parseInt(darkCount.value) || 0;
  const midN = parseInt(midCount.value) || 0;
  const lightN = parseInt(lightCount.value) || 0;
  const total = darkN + midN + lightN;
  const currentTotal = parseInt(colorCount.value) || 0;
  
  if (total > currentTotal) {
    colorCount.value = total;
  }
  extractPalette();
});
lightCount.addEventListener('input', () => {
  // Обновляем общее количество только если сумма больше текущего значения
  const darkN = parseInt(darkCount.value) || 0;
  const midN = parseInt(midCount.value) || 0;
  const lightN = parseInt(lightCount.value) || 0;
  const total = darkN + midN + lightN;
  const currentTotal = parseInt(colorCount.value) || 0;
  
  if (total > currentTotal) {
    colorCount.value = total;
  }
  extractPalette();
});

// Обработчики для работы с фактическими цветами
addColorBtn.addEventListener('click', () => {
  addActualColor();
});

matchColorsBtn.addEventListener('click', () => {
  matchColors();
});

syncPaletteBtn.addEventListener('click', () => {
  syncActualWithCalculated();
});

syncWithCalculated.addEventListener('change', () => {
  if (syncWithCalculated.checked && currentPalette.length > 0) {
    syncActualWithCalculated();
  }
});

autoMatchColors.addEventListener('change', () => {
  if (autoMatchColors.checked && currentPalette.length > 0 && actualPalette.length > 0) {
    matchColors();
  }
});

// Обработчики для StringArt
canvasShape.addEventListener('change', generateStringartPreview);
canvasSize.addEventListener('change', generateStringartPreview);
nailCount.addEventListener('input', generateStringartPreview);

// Обновляем схему StringArt при изменении фактических цветов
function updateStringartPreview() {
  if (stringartSection.classList.contains('active')) {
    generateStringartPreview();
  }
}

// Обновляем фактические маски при изменении размытия
maskBlur.addEventListener('input', () => {
  maskBlurInput.value = maskBlur.value;
  generateColorMaps();
  if (colorMapping.length > 0) {
    generateActualColorMaps();
  }
});

maskBlurInput.addEventListener('input', () => {
  maskBlur.value = maskBlurInput.value;
  generateColorMaps();
  if (colorMapping.length > 0) {
    generateActualColorMaps();
  }
});

// ====== Карты ======
// Новая функция генерации карт (вынесена из buildMapsBtn)
function generateColorMaps(){
  colorMaps.innerHTML='';
  if(!secondImg.src||currentPalette.length===0)return;
  const canvas=document.createElement('canvas');const ctx=canvas.getContext('2d');
  canvas.width=secondImg.naturalWidth;canvas.height=secondImg.naturalHeight;
  ctx.drawImage(secondImg,0,0);const imageData=ctx.getImageData(0,0,canvas.width,canvas.height);
  const data=imageData.data;
  // Переводим цвета палитры из HEX в RGB
  const paletteRGB=currentPalette.map(hex=>{
    const bigint=parseInt(hex.slice(1),16);
    return[(bigint>>16)&255,(bigint>>8)&255,(bigint)&255];
  });
  // Для каждого цвета создаём отдельную карту
  paletteRGB.forEach((color,index)=>{
    const mapCanvas=document.createElement('canvas');const mapCtx=mapCanvas.getContext('2d');
    mapCanvas.width=canvas.width;mapCanvas.height=canvas.height;
    const mapImageData=mapCtx.createImageData(canvas.width,canvas.height);const mapData=mapImageData.data;
    for(let i=0;i<data.length;i+=4){
      const r=data[i],g=data[i+1],b=data[i+2];
      // Для каждого пикселя ищем ближайший цвет из палитры
      const distances=paletteRGB.map(c=>Math.sqrt((r-c[0])**2+(g-c[1])**2+(b-c[2])**2));
      const minIndex=distances.indexOf(Math.min(...distances));
      // Если этот цвет — текущий, делаем пиксель чёрным, иначе белым
      if(minIndex===index){mapData[i]=0;mapData[i+1]=0;mapData[i+2]=0;mapData[i+3]=255;}
      else{mapData[i]=255;mapData[i+1]=255;mapData[i+2]=255;mapData[i+3]=255;}
    }
    // Применяем размытие к маске, если нужно
    let blurValue = parseInt(maskBlur.value)||0;
    if(blurValue>0){
      mapCtx.putImageData(mapImageData,0,0);
      mapCtx.filter = `blur(${blurValue}px)`;
      mapCtx.drawImage(mapCanvas,0,0);
      mapCtx.filter = '';
      // После размытия снова получаем данные
      const blurred = mapCtx.getImageData(0,0,mapCanvas.width,mapCanvas.height);
      mapCtx.putImageData(blurred,0,0);
    } else {
      mapCtx.putImageData(mapImageData,0,0);
    }
    const img=document.createElement('img');img.src=mapCanvas.toDataURL();
    img.style.border = `4px solid ${currentPalette[index]}`;colorMaps.appendChild(img);
  });
}

// === Пипетка только для второго изображения ===
// Получаем ссылку на оверлей и изображение
const pipetteOverlay = document.getElementById('pipetteOverlay');
const pipetteImg = document.getElementById('pipetteImg');

// Открытие режима пипетки
pipetteImg.addEventListener('click', function(e) {
  if (!secondImg.src) return;
  pipetteImg.src = secondImg.src;
  pipetteOverlay.style.display = 'flex';
});
// Клик по оверлею вне картинки — закрыть
pipetteOverlay.addEventListener('click', function(e) {
  if (e.target === pipetteOverlay) pipetteOverlay.style.display = 'none';
});
// Клик по изображению в оверлее — выбор цвета
pipetteImg.addEventListener('click', function(e) {
  // Используем window.__activePipetteIndex
  const idx = window.__activePipetteIndex;
  if (typeof idx === 'undefined' || idx === null) return;
  const rect = pipetteImg.getBoundingClientRect();
  const x = Math.floor((e.clientX - rect.left) / rect.width * pipetteImg.naturalWidth);
  const y = Math.floor((e.clientY - rect.top) / rect.height * pipetteImg.naturalHeight);
  const canvas = document.createElement('canvas');
  canvas.width = pipetteImg.naturalWidth;
  canvas.height = pipetteImg.naturalHeight;
  const ctx = canvas.getContext('2d');
  ctx.drawImage(pipetteImg, 0, 0);
  const pixel = ctx.getImageData(x, y, 1, 1).data;
  const hex = '#' + [pixel[0], pixel[1], pixel[2]].map(v => v.toString(16).padStart(2, '0')).join('');
  currentPalette[idx] = hex;
  renderPalette();
  generateColorMaps();
  pipetteOverlay.style.display = 'none';
  window.__activePipetteIndex = null;
});
// Удаляем обычный обработчик клика по secondImg (если был)
secondImg.onclick = null;
</script>
</body>
</html>
