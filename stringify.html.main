<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Telegram Mini App — Фото и Палитра</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
    :root {
      --bg: #0f1115;
      --card: #151924;
      --text: #e7e9ee;
      --muted: #9aa3b2;
      --accent: #2ea6ff;
      --border: #1f2430;
    }
    body { margin:0; font-family:system-ui,sans-serif; color:var(--text); background:var(--bg);}
    .app {display:flex;flex-direction:column;min-height:100dvh;}
    header.app-header{display:flex;gap:12px;padding:12px;background:var(--card);border-bottom:1px solid var(--border);}
    header.app-header button{border:1px solid var(--border);background:transparent;color:var(--text);padding:10px 14px;border-radius:12px;font-weight:600;cursor:pointer;}
    header.app-header button.primary{background:var(--accent);border-color:transparent;color:#081018;}
    main{display:grid;place-items:center;padding:16px;flex:1;}
    .card{width:min(720px,100%);background:var(--card);border:1px solid var(--border);border-radius:20px;box-shadow:0 10px 30px rgba(0,0,0,.35);overflow:hidden;}
    video{display:none;max-width:100%;border-top:1px solid var(--border);background:#000;}
    .preview{display:none;border-top:1px solid var(--border);background:#0c0f15;padding-bottom:10px;}
    .preview.active{display:block;}
    .preview-label{padding:10px 16px;font-weight:bold;}
    .preview img{display:block;width:100%;height:auto;object-fit:contain;background:#000;max-height:70dvh;}
    .second-preview{display:none;border-top:1px solid var(--border);padding:10px 16px;}
    .second-preview.active{display:block;}
    .second-preview img{width:100%;height:auto;}
    .settings{margin-top:10px;}
    .settings label{display:block;margin-top:8px;}
    .settings input[type=range]{width:60%;}
    .settings input[type=number]{width:80px;margin-left:10px;}
    .settings span{margin-left:10px;}
    .palette {margin-top:10px;}
    .color-item{display:inline-block;margin:5px;text-align:center;}
    .color-circle{width:32px;height:32px;border-radius:50%;border:2px solid #fff;cursor:pointer;}
    .color-code{font-size:12px;margin-top:4px;}
    #colorMaps img{max-width:32%;border:2px solid var(--border);}
  </style>
</head>
<body>
<div class="app">
  <header class="app-header">
    <button id="uploadBtn" class="primary" type="button">Выбрать файл</button>
    <button id="cameraBtn" type="button">Сделать фото</button>
    <button id="resetBtn" type="button" style="display:none">Сброс</button>
  </header>
  <main>
    <section class="card">
      <video id="cameraStream" autoplay playsinline></video>
      <canvas id="snapshotCanvas" style="display:none"></canvas>

      <!-- 1) -->
      <div id="preview" class="preview">
        <div class="preview-label">1)</div>
        <img id="previewImg" alt="Предпросмотр"/>
      </div>

      <!-- 2) -->
      <div id="secondPreview" class="second-preview">
        <div class="preview-label">2)</div>
        <img id="secondImg" alt="Изменённое"/>
        <div class="settings">
          <label>
            Ширина (px):
            <input type="range" id="resolutionRange" min="50" max="1000" step="1" value="200">
            <input type="number" id="resolutionInput" min="50" max="1000" step="1" value="200">
            <span id="percentDisplay">20%</span>
          </label>
          <label>
            Размытие (px):
            <input type="range" id="blurRange" min="0" max="20" step="0.1" value="0">
            <input type="number" id="blurInput" min="0" max="20" step="0.1" value="0">
          </label>
        </div>
      </div>

      <!-- 3) -->
      <div id="paletteSection" class="second-preview">
        <div class="preview-label">3)</div>
        <div class="settings">
          <label>
            Кол-во цветов:
            <select id="colorCount">
              <option value="3" selected>3</option>
              <option value="6">6</option>
              <option value="9">9</option>
            </select>
          </label>
          <label>
            Минимальная ΔE:
            <input type="number" id="minDeltaE" min="1" max="100" value="25">
          </label>
          <label>
            Тёмные:
            <input type="number" id="darkCount" min="0" max="9" value="2" style="width:40px;">
          </label>
          <label>
            Средние:
            <input type="number" id="midCount" min="0" max="9" value="2" style="width:40px;">
          </label>
          <label>
            Светлые:
            <input type="number" id="lightCount" min="0" max="9" value="2" style="width:40px;">
          </label>
          <label>
            Смягчение масок:
            <input type="range" id="maskBlur" min="0" max="20" step="0.1" value="0" style="width:100px;">
            <input type="number" id="maskBlurInput" min="0" max="20" step="0.1" value="0" style="width:40px;">
          </label>
        </div>
        <div id="palette" class="palette"></div>
        <div id="colorMaps" style="margin-top:10px;display:flex;flex-wrap:wrap;gap:10px;"></div>
      </div>
    </section>
  </main>
</div>

<script>
// =========================
// Этот скрипт реализует работу мини-приложения для Telegram,
// которое позволяет выбрать или сделать фото, изменить его размер и размытость,
// а также получить палитру основных цветов и построить цветовые карты.
// =========================

// Создаём скрытый input для загрузки файла изображения
const fileInput=document.createElement('input');
fileInput.type='file'; // Тип input — файл
fileInput.accept='image/*'; // Принимаются только изображения
fileInput.capture='environment'; // Открывать камеру по умолчанию на мобильных
fileInput.style.display='none'; // Скрываем элемент
// Добавляем input на страницу
document.body.appendChild(fileInput);

// Получаем ссылки на все нужные элементы интерфейса по их id
const uploadBtn=document.getElementById('uploadBtn'); // Кнопка "Выбрать файл"
const cameraBtn=document.getElementById('cameraBtn'); // Кнопка "Сделать фото"
const resetBtn=document.getElementById('resetBtn'); // Кнопка "Сброс"
const preview=document.getElementById('preview'); // Блок предпросмотра
const previewImg=document.getElementById('previewImg'); // Картинка предпросмотра
const cameraStream=document.getElementById('cameraStream'); // Видео с камеры
const snapshotCanvas=document.getElementById('snapshotCanvas'); // Канвас для снимка
const resolutionRange=document.getElementById('resolutionRange'); // Слайдер ширины
const resolutionInput=document.getElementById('resolutionInput'); // Поле ширины
const percentDisplay=document.getElementById('percentDisplay'); // Отображение процента
const secondPreview=document.getElementById('secondPreview'); // Блок изменённого изображения
const secondImg=document.getElementById('secondImg'); // Изменённое изображение
const blurRange=document.getElementById('blurRange'); // Слайдер размытия
const blurInput=document.getElementById('blurInput'); // Поле размытия
const paletteSection=document.getElementById('paletteSection'); // Блок палитры
const colorCount=document.getElementById('colorCount'); // Количество цветов
const minDeltaEInput=document.getElementById('minDeltaE'); // Минимальная разница цветов
const paletteDiv=document.getElementById('palette'); // Палитра цветов
const colorMaps=document.getElementById('colorMaps'); // Блок для цветовых карт

// Получаем ссылки на новые поля
const darkCount = document.getElementById('darkCount');
const midCount = document.getElementById('midCount');
const lightCount = document.getElementById('lightCount');

// Получаем ссылки на новые элементы
const maskBlur = document.getElementById('maskBlur');
const maskBlurInput = document.getElementById('maskBlurInput');
// Синхронизация слайдера и поля
maskBlur.addEventListener('input',()=>{maskBlurInput.value=maskBlur.value;generateColorMaps();});
maskBlurInput.addEventListener('input',()=>{maskBlur.value=maskBlurInput.value;generateColorMaps();});

// Переменные для хранения исходного изображения и палитры
let originalImage=null,originalWidth=0,currentPalette=[];

// --- Функция для загрузки тестового изображения по умолчанию ---
function loadDefaultImage() {
  const defaultImgUrl = 'https://sun9-83.userapi.com/s/v1/ig1/XJRPO-T4RuE0KFMctnOM20rCs68dYcO4H5KnFW6s5E_x1BlQhkN2lojil1AW11LQ6xGG1uKa.jpg?quality=96&as=32x40,48x60,72x90,108x135,160x200,240x300,360x449,480x599,540x674,640x799,720x899,865x1080&from=bu&cs=865x0';
  const img = new Image();
  img.crossOrigin = 'Anonymous'; // Важно для работы с canvas!
  img.onload = () => {
    // Копируем изображение в canvas и получаем dataURL
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = img.width;
    tempCanvas.height = img.height;
    const ctx = tempCanvas.getContext('2d');
    ctx.drawImage(img, 0, 0);
    const dataURL = tempCanvas.toDataURL('image/png');
    previewImg.src = dataURL;
    preview.classList.add('active');
    originalImage = dataURL;
    originalWidth = img.width;
    uploadBtn.style.display = '';
    cameraBtn.style.display = '';
    resetBtn.style.display = '';
    resolutionRange.max = img.width;
    resolutionInput.max = img.width;
    resolutionRange.value = img.width * 0.2;
    resolutionInput.value = img.width * 0.2;
    percentDisplay.textContent = '20%';
    applyResolution();
  };
  img.src = defaultImgUrl;
}
// --- Загружаем тестовое изображение при старте ---
window.addEventListener('DOMContentLoaded', loadDefaultImage);

// Обработчик кнопки "Выбрать файл" — открывает диалог выбора файла
uploadBtn.addEventListener('click',()=>fileInput.click());
// Когда выбран файл, вызываем функцию обработки файла
fileInput.addEventListener('change',()=>{const f=fileInput.files?.[0];if(f)handleFile(f);});

// Обработчик кнопки "Сброс" — возвращает приложение в исходное состояние
resetBtn.addEventListener('click',()=>{
  fileInput.value='';
  previewImg.removeAttribute('src');
  preview.classList.remove('active');
  secondImg.removeAttribute('src');
  secondPreview.classList.remove('active');
  paletteSection.classList.remove('active');
  colorMaps.innerHTML='';
  cameraStream.style.display='none';
  resetBtn.style.display='none';
  uploadBtn.style.display='';
  cameraBtn.style.display='';
  resolutionRange.value=200;resolutionInput.value=200;percentDisplay.textContent='20%';
  blurRange.value=0;blurInput.value=0;
  originalImage=null;originalWidth=0;
  // После сброса снова показываем тестовое изображение
  loadDefaultImage();
});

// Обработчик кнопки "Сделать фото" — включает камеру и делает снимок через 3 секунды
cameraBtn.addEventListener('click',async()=>{
  try{
    const stream=await navigator.mediaDevices.getUserMedia({video:true}); // Запрашиваем доступ к камере
    cameraStream.srcObject=stream;cameraStream.style.display='block'; // Показываем видео
    setTimeout(()=>takeSnapshot(stream),3000); // Через 3 секунды делаем снимок
  }catch(err){alert('Не удалось открыть камеру:'+err);}
});

// Функция делает снимок с камеры и отображает его
function takeSnapshot(stream){
  const ctx=snapshotCanvas.getContext('2d');
  snapshotCanvas.width=cameraStream.videoWidth;
  snapshotCanvas.height=cameraStream.videoHeight;
  ctx.drawImage(cameraStream,0,0); // Копируем изображение с видео на канвас
  const dataURL=snapshotCanvas.toDataURL('image/png'); // Получаем картинку в виде строки
  previewImg.src=dataURL;preview.classList.add('active'); // Показываем предпросмотр
  originalImage=dataURL;originalWidth=cameraStream.videoWidth; // Сохраняем данные
  cameraStream.style.display='none';stream.getTracks().forEach(t=>t.stop()); // Отключаем камеру
  uploadBtn.style.display='none';cameraBtn.style.display='none';resetBtn.style.display=''; // Меняем кнопки
  resolutionRange.value=originalWidth*0.2;resolutionInput.value=originalWidth*0.2;percentDisplay.textContent='20%'; // Ставим ширину 20%
  applyResolution(); // Применяем изменения
}

// Функция обработки выбранного файла изображения
function handleFile(file){
  if(!file||!file.type.startsWith('image/')){
    // Если файл не выбран или не является изображением, ничего не делаем
    return;
  }
  const r = new FileReader();
  r.onload = () => {
    const img = new Image();
    img.onload = () => {
      previewImg.src = r.result;
      preview.classList.add('active');
      originalImage = r.result;
      originalWidth = img.width;
      uploadBtn.style.display = 'none';
      cameraBtn.style.display = 'none';
      resetBtn.style.display = '';
      resolutionRange.max = img.width;
      resolutionInput.max = img.width;
      resolutionRange.value = img.width * 0.2;
      resolutionInput.value = img.width * 0.2;
      percentDisplay.textContent = '20%';
      applyResolution();
    };
    img.src = r.result;
  };
  r.readAsDataURL(file);
}

// Функция обновляет отображение процента ширины
function updatePercent(){
  percentDisplay.textContent=Math.round((resolutionInput.value/originalWidth)*100)+'%';
}

// Обработчики изменения ширины и размытия изображения
resolutionRange.addEventListener('input',()=>{resolutionInput.value=resolutionRange.value;updatePercent();applyResolution();});
resolutionInput.addEventListener('input',()=>{resolutionRange.value=resolutionInput.value;updatePercent();applyResolution();});
blurRange.addEventListener('input',()=>{blurInput.value=blurRange.value;applyResolution();});
blurInput.addEventListener('input',()=>{blurRange.value=blurInput.value;applyResolution();});

// Функция применяет выбранную ширину и размытие к изображению
function applyResolution(){
  if(!originalImage)return;
  const img=new Image();
  img.onload=()=>{
    const newWidth=parseInt(resolutionInput.value);const scale=newWidth/originalWidth;
    const ctx=snapshotCanvas.getContext('2d');
    snapshotCanvas.width=newWidth;snapshotCanvas.height=img.height*scale;
    ctx.filter=`blur(${blurInput.value}px)`;ctx.drawImage(img,0,0,snapshotCanvas.width,snapshotCanvas.height);
    ctx.filter='';
    secondImg.onload = () => {
      secondPreview.classList.add('active');
      paletteSection.classList.add('active');
      extractPalette(); // теперь палитра строится по реально обновлённому изображению
    };
    secondImg.src=snapshotCanvas.toDataURL('image/png');
    secondImg.style.width='100%';
  };
  img.src=originalImage;
}

// ======= Палитра с minDeltaE =======
// Функция переводит цвет из RGB в LAB (для сравнения различия цветов)
function rgbToLab(r,g,b){function pivot(n){return n>0.008856?Math.pow(n,1/3):(7.787*n)+(16/116);}
  r/=255;g/=255;b/=255;
  r=r>0.04045?Math.pow((r+0.055)/1.055,2.4):r/12.92;
  g=g>0.04045?Math.pow((g+0.055)/1.055,2.4):g/12.92;
  b=b>0.04045?Math.pow((b+0.055)/1.055,2.4):b/12.92;
  let x=(r*0.4124+g*0.3576+b*0.1805)/0.95047;
  let y=(r*0.2126+g*0.7152+b*0.0722)/1.000;
  let z=(r*0.0193+g*0.1192+b*0.9505)/1.08883;
  x=pivot(x);y=pivot(y);z=pivot(z);
  return[(116*y)-16,500*(x-y),200*(y-z)];
}
// Функция считает "различие" между двумя цветами в LAB
function deltaE(a,b){return Math.sqrt((a[0]-b[0])**2+(a[1]-b[1])**2+(a[2]-b[2])**2);}
// Фильтрует цвета, чтобы в палитре были только достаточно отличающиеся друг от друга
function filterColorsByDeltaE(colors,minDeltaE){
 let res=[];colors.forEach(c=>{
   let lab=rgbToLab(c[0],c[1],c[2]);
   if(!res.some(r=>deltaE(lab,r.lab)<minDeltaE)){res.push({rgb:c,lab});}
 });return res.map(r=>r.rgb);
}
// Извлекает палитру основных цветов из изображения
function extractPalette(){
 if(!secondImg.src)return;
 const canvas=document.createElement('canvas');const ctx=canvas.getContext('2d');
 canvas.width=secondImg.naturalWidth;canvas.height=secondImg.naturalHeight;
 ctx.drawImage(secondImg,0,0);
 const data=ctx.getImageData(0,0,canvas.width,canvas.height).data;
 let sampleColors=[];
 for(let i=0;i<data.length;i+=40*4){sampleColors.push([data[i],data[i+1],data[i+2]]);}
 // Сортируем по яркости (L из LAB)
 let colorsWithL = sampleColors.map(rgb => {
   let lab = rgbToLab(rgb[0], rgb[1], rgb[2]);
   return {rgb, L: lab[0]};
 });
 colorsWithL.sort((a, b) => a.L - b.L);
 // Разбиваем на 3 группы: тёмные, средние, светлые
 let n = colorsWithL.length;
 let borders = [Math.floor(n/3), Math.floor(2*n/3)];
 let groups = [[],[],[]];
 for(let i=0;i<n;i++){
   if(i < borders[0]) groups[0].push(colorsWithL[i].rgb);
   else if(i < borders[1]) groups[1].push(colorsWithL[i].rgb);
   else groups[2].push(colorsWithL[i].rgb);
 }
 // Получаем желаемое количество из каждой группы
 let darkN = parseInt(darkCount.value)||0;
 let midN = parseInt(midCount.value)||0;
 let lightN = parseInt(lightCount.value)||0;
 let total = darkN + midN + lightN;
 // Если total не совпадает с выбранным colorCount, корректируем colorCount
 colorCount.value = total;
 // В каждой группе выбираем отличающиеся цвета
 let uniq = [];
 let filteredDark = filterColorsByDeltaE(groups[0],parseInt(minDeltaEInput.value));
 let filteredMid = filterColorsByDeltaE(groups[1],parseInt(minDeltaEInput.value));
 let filteredLight = filterColorsByDeltaE(groups[2],parseInt(minDeltaEInput.value));
 uniq = uniq.concat(filteredDark.slice(0,darkN));
 uniq = uniq.concat(filteredMid.slice(0,midN));
 uniq = uniq.concat(filteredLight.slice(0,lightN));
 uniq = uniq.slice(0,total); // если вдруг перебор
 currentPalette=uniq.map(c=>'#'+((1<<24)+(c[0]<<16)+(c[1]<<8)+c[2]).toString(16).slice(1));
 renderPalette();
 generateColorMaps();
}
// Отображает палитру на странице, позволяет менять цвета вручную
function renderPalette(){
  paletteDiv.innerHTML='';currentPalette.forEach((col,idx)=>{
    const item=document.createElement('div');item.className='color-item';
    const circle=document.createElement('input');circle.type='color';circle.value=col;circle.className='color-circle';
    const code=document.createElement('input');code.type='text';code.value=col;code.className='color-code';
    // Можно вручную менять цвет через input
    circle.addEventListener('input',()=>{
      code.value=circle.value;
      currentPalette[idx]=circle.value;
      generateColorMaps(); // обновляем карты при изменении цвета
    });
    code.addEventListener('input',()=>{
      circle.value=code.value;
      currentPalette[idx]=code.value;
      generateColorMaps(); // обновляем карты при изменении цвета
    });
    item.appendChild(circle);item.appendChild(code);paletteDiv.appendChild(item);
  });
}
// Обновляем палитру при изменении количества цветов, minDeltaE или пропорций
colorCount.addEventListener('change',()=>{
  // При смене общего количества — корректируем пропорции
  let val = parseInt(colorCount.value);
  // Пропорции по умолчанию: 1/1/1 для 3, 2/2/2 для 6, 3/3/3 для 9
  if(val === 3){darkCount.value=1;midCount.value=1;lightCount.value=1;}
  else if(val === 6){darkCount.value=2;midCount.value=2;lightCount.value=2;}
  else if(val === 9){darkCount.value=3;midCount.value=3;lightCount.value=3;}
  extractPalette();
});
darkCount.addEventListener('input',extractPalette);
midCount.addEventListener('input',extractPalette);
lightCount.addEventListener('input',extractPalette);
minDeltaEInput.addEventListener('input',extractPalette);

// ====== Карты ======
// Новая функция генерации карт (вынесена из buildMapsBtn)
function generateColorMaps(){
  colorMaps.innerHTML='';
  if(!secondImg.src||currentPalette.length===0)return;
  const canvas=document.createElement('canvas');const ctx=canvas.getContext('2d');
  canvas.width=secondImg.naturalWidth;canvas.height=secondImg.naturalHeight;
  ctx.drawImage(secondImg,0,0);const imageData=ctx.getImageData(0,0,canvas.width,canvas.height);
  const data=imageData.data;
  // Переводим цвета палитры из HEX в RGB
  const paletteRGB=currentPalette.map(hex=>{
    const bigint=parseInt(hex.slice(1),16);
    return[(bigint>>16)&255,(bigint>>8)&255,(bigint)&255];
  });
  // Для каждого цвета создаём отдельную карту
  paletteRGB.forEach((color,index)=>{
    const mapCanvas=document.createElement('canvas');const mapCtx=mapCanvas.getContext('2d');
    mapCanvas.width=canvas.width;mapCanvas.height=canvas.height;
    const mapImageData=mapCtx.createImageData(canvas.width,canvas.height);const mapData=mapImageData.data;
    for(let i=0;i<data.length;i+=4){
      const r=data[i],g=data[i+1],b=data[i+2];
      // Для каждого пикселя ищем ближайший цвет из палитры
      const distances=paletteRGB.map(c=>Math.sqrt((r-c[0])**2+(g-c[1])**2+(b-c[2])**2));
      const minIndex=distances.indexOf(Math.min(...distances));
      // Если этот цвет — текущий, делаем пиксель чёрным, иначе белым
      if(minIndex===index){mapData[i]=0;mapData[i+1]=0;mapData[i+2]=0;mapData[i+3]=255;}
      else{mapData[i]=255;mapData[i+1]=255;mapData[i+2]=255;mapData[i+3]=255;}
    }
    // Применяем размытие к маске, если нужно
    let blurValue = parseInt(maskBlur.value)||0;
    if(blurValue>0){
      mapCtx.putImageData(mapImageData,0,0);
      mapCtx.filter = `blur(${blurValue}px)`;
      mapCtx.drawImage(mapCanvas,0,0);
      mapCtx.filter = '';
      // После размытия снова получаем данные
      const blurred = mapCtx.getImageData(0,0,mapCanvas.width,mapCanvas.height);
      mapCtx.putImageData(blurred,0,0);
    } else {
      mapCtx.putImageData(mapImageData,0,0);
    }
    const img=document.createElement('img');img.src=mapCanvas.toDataURL();
    img.style.border = `4px solid ${currentPalette[index]}`;colorMaps.appendChild(img);
  });
}
</script>
</body>
</html>
